<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<title>
			bomberman
		</title>
		<link rel="stylesheet" href="">
		<script src='prototype.js'>
				
		</script>
	</head>
	<body>
		<canvas width='1000' height='500'>
		</canvas>
		<script type="text/javascript">
			var Obj = Class.create();
			Obj.prototype = {
				position: {
					x: 0,
					y: 0
				},
				type: 0,
				destroyable: 1,
				initialize: function(opts) {
					this.type = opts.type;
				}
			}

			var Cell = Class.create();
			Cell.prototype = {
				initialize: function (opts) {
					this.objects = [];
				}
			}

			var Map = Class.create({
				cells: [],
				initialize: function (opts) {
					if (typeof opts.grid !== 'undefined') {
						for (var i = 0; i < opts.grid.length; i++) {
							this.cells[i] = new Array(opts.grid[i].length);
							for (var j = 0; j < opts.grid[i].length; j++) {
								this.cells[i][j] = new Cell();
								var self = this;
								this.cells[i][j].add(
									self.createObj({
										type: opts.grid[i][j],
										position: {
											x: i,
											y: j
										}
									})
								);
							};
						};
					}
					
				}
			});

			var Player = Class.create(Obj, {
				destroyable: 1,
				bombLimit: 2,
				bombPlained: [],
				bombRange: 3
			});

			var Bomb = Class.create(Obj, {
				initialize: function(opts) {
					this.owner = opts.owner;
					this.position = Object.clone(this.owner.position);
					var self = this;
					this.owner.bombPlained.push(self);
					setTimeout(function () {
						self.explode(self)
					}, this.timer);
				},
				destroyable: 1,
				owner: {},
				timer: 3000
			});

			var Block = Class.create(Obj, {
				destroyable: 1
			});

			var BlockSeparator = Class.create(Block, {
				destroyable: 0
			});

			Obj.prototype.destroy = function (opts) {
				delete this;
			}

			Cell.prototype.destroy = function (opts) {
				if (!this.hasUndestroyable()) {
					for (var i = 0; i < this.objects.length; i++) {
						this.objects[i].destroy(opts);
					};
					console.log('all block at cell ' + opts.position.x + '|' + opts.position.y + ' are destroyed');
					return true;
				}
				return false;
			}

			Cell.prototype.add = function (obj) {
				this.objects.push(obj);
			}

			Cell.prototype.remove = function (obj) {
				this.objects.remove(this.objects.indexOf(obj), this.objects.indexOf(obj));
			}

			Cell.prototype.hasUndestroyable = function () {
				for (var i = 0; i < this.objects.length; i++) {
					if (!this.objects[i].destroyable) {
						return true;
					}
				}
				return false;
			}

			Cell.prototype.getBlocks = function () {
				return this.objects;
			}

			Map.prototype.createObj = function (opts) {
				var obj;
				switch(opts.type) {
					case 'player':
						obj = new Player(opts);
						break;
					case 'bomb': 
						obj = new Bomb(opts);
						break;
					case 'sepBlock':
						obj = new BlockSeparator(opts);
						break;
					default:
						obj = new Obj(opts);
				}
				obj.map = this;
				return obj;	
			}

			Map.prototype.getPlayer = function (n) {
				for (var i = 0; i < this.cells.length; i++) {
					for (var j = 0; j < this.cells[i].length; j++) {
						for (var k in this.cells[i][j].objects) {
							if (this.cells[i][j].objects[k].type === 'player') {
								n--;
								if (!n) {
									return this.cells[i][j].objects[k];
								}
							}
						}
					}
				}
			}

			Map.prototype.getCell = function (position) {
				if (typeof this.cells === 'undefined') {
					console.log('there is not cell with coordinates ' + position.x + '|' + position.y);
					return null;
				} else {
					return this.cells[this.position.x][this.position.y].getAllBlocks();
				}
			}

			Player.prototype.plainBomb = function() {
				if (this.bombPlained.length !== this.bombLimit) {

					var bomb = this.map.createObj({
						type:'bomb',
						owner: this
					});
				}

				console.log('bomb is plained');
				console.log('bombs list:');
				console.log(this.bombPlained);
			};

			Player.prototype.move = function(x, y) {
				this.position.x = x;
				this.position.y = y;
			}

			Player.prototype.destroy = function (opts) {
				console.log('Player is dead from now');
				if (opts.owner === this) {
					console.log('it was suicide');
				}
			}


			Bomb.prototype.explode = function(self) {
				var player = self.owner;
				var cells = player.map.cells;
				var x = this.position.x,
					y = this.position.y;

				console.log('booom!');

				if (!cells[x][y].hasUndestroyable()) {
					cells[x][y].destroy(this);
				}

				for (var i = 1; i < player.bombRange + 1; i++) {
					if ((x - i) > 0 && (x - i) < cells.length - 1) {
						if (!cells[x - i][y].hasUndestroyable()) {
							cells[x - i][y].destroy(this);
						} else {
							break;
						}
					}
				}
				for (var i = 1; i < player.bombRange + 1; i++) {
					if ((x + i) > 0 && (x + i) < cells.length - 1) {
						if (!cells[x + i][y].hasUndestroyable()) {
							cells[x + i][y].destroy(this);
						} else {
							break;
						}
					}
				}
				for (var i = 1; i < player.bombRange + 1; i++) {
					if ((y - 1) > 0 && (y - 1) < cells[x].length - 1) {
						if (!cells[x][y - 1].hasUndestroyable()) {
							cells[x][y - 1].destroy(this);
						} else {
							break;
						}
					}
				}
				for (var i = 1; i < player.bombRange + 1; i++) {
					if ((y + 1) > 0 && (y + 1) < cells[x].length - 1) {
						if (!cells[x][y + 1].hasUndestroyable()) {
							cells[x][y + 1].destroy(this);
						} else {
							break;
						}
					}
				}


				console.log('bomb exploded');

				// recalculate bombs count after exploding
				player.bombPlained.remove(player.bombPlained.indexOf(self), player.bombPlained.indexOf(self));
				console.log(player.bombPlained);
			}


			var map = new Map({
				grid: [
					['player',0,0,0,0,0,0,0,0,0,0],
					[0,'sepBlock',0,'sepBlock',0,'sepBlock',0,'sepBlock',0,'sepBlock',0],
					[0,'brick','brick','brick','brick','brick','brick','brick','brick','brick','brick'],
					['brick','sepBlock',0,'sepBlock',0,'sepBlock',0,'sepBlock',0,'sepBlock',0],
					['brick','brick','brick','brick','brick','brick','brick','brick','brick','brick','brick'],
					[0,'sepBlock',0,'sepBlock',0,'sepBlock',0,'sepBlock',0,'sepBlock',0],
					['brick','brick','brick','brick','brick','brick','brick','brick','brick','brick','brick'],
					[0,'sepBlock',0,'sepBlock',0,'sepBlock',0,'sepBlock',0,'sepBlock',0],
					['brick','brick','brick','brick','brick','brick','brick','brick','brick','brick','brick'],
					[0,'sepBlock',0,'sepBlock',0,'sepBlock',0,'sepBlock',0,'sepBlock',0],
					[0,0,0,0,0,0,0,0,0,0,0]
				]
			});
			var p = map.getPlayer(1);
			
			var b = new Bomb({owner: p});


			Array.prototype.remove = function(from, to) {
				var rest = this.slice((to || from) + 1 || this.length);
				this.length = from < 0 ? this.length + from : from;
				return this.push.apply(this, rest);
			};
		</script>
	</body>

</html>